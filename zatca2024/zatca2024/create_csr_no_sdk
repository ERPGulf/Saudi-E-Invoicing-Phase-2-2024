from cryptography import x509
from cryptography.hazmat._oid import NameOID
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.bindings._rust import ObjectIdentifier
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
import base64
import json
import requests
from lxml import etree
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.hashes import SHA256
import signxml
from lxml import etree
import base64


# corrected by Farook the csr

def get_csr_data():
    # Read the properties file
            with open('sdkcsrconfig.properties', 'r') as file:
                lines = [line.strip() for line in file.readlines()]

            # Initialize variables
            csr_common_name = None
            csr_serial_number = None
            csr_organization_identifier = None
            csr_organization_unit_name = None
            csr_organization_name = None
            csr_country_name = None
            csr_invoice_type = None
            csr_location_address = None
            csr_industry_business_category = None

            # Process each line to extract key-value pairs
            for line in lines:
                parts = line.split('=')
                if len(parts) == 2:
                    key, value = parts
                    if key == 'csr.common.name':
                        csr_common_name = value
                    elif key == 'csr.serial.number':
                        csr_serial_number = value
                    elif key == 'csr.organization.identifier':
                        csr_organization_identifier = value
                    elif key == 'csr.organization.unit.name':
                        csr_organization_unit_name = value
                    elif key == 'csr.organization.name':
                        csr_organization_name = value
                    elif key == 'csr.country.name':
                        csr_country_name = value
                    elif key == 'csr.invoice.type':
                        csr_invoice_type = value
                    elif key == 'csr.location.address':
                        csr_location_address = value
                    elif key == 'csr.industry.business.category':
                        csr_industry_business_category = value

            return csr_common_name,csr_serial_number,csr_organization_identifier,csr_organization_unit_name,csr_organization_name,csr_country_name,csr_invoice_type,csr_location_address,csr_industry_business_category


def create_private_key():
        private_key = ec.generate_private_key(ec.SECP256K1(), backend=default_backend())
        private_key_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption()
        )
        return private_key_pem

private_key_pem =create_private_key()
def create_csr(portal_type):
    
        csr_common_name,csr_serial_number,csr_organization_identifier,csr_organization_unit_name,csr_organization_name,csr_country_name,csr_invoice_type,csr_location_address,csr_industry_business_category = get_csr_data()
        if portal_type == "sandbox":
            customoid = b"..TESTZATCA-Code-Signing"
        elif portal_type == "simulation":
            customoid = b"..PREZATCA-Code-Signing"
        else:
            customoid = b"..ZATCA-Code-Signing"

        private_key_pem = create_private_key()
        private_key = serialization.load_pem_private_key(private_key_pem, password=None, backend=default_backend())
        
        custom_oid_string = "2.5.9.3.7.1.982.20.2"
        custom_value = customoid
        oid = ObjectIdentifier(custom_oid_string)
        custom_extension = x509.extensions.UnrecognizedExtension(oid, custom_value)
        
        dn = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, csr_common_name),  # csr.common.name
            x509.NameAttribute(NameOID.COUNTRY_NAME, csr_country_name),   # csr.country.name -  has to be two digits 
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, csr_organization_name),   # csr.organization.name
            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, csr_organization_unit_name), # csr.organization.unit.name
        ])
        alt_name = x509.SubjectAlternativeName({
            x509.DirectoryName(x509.Name([
                x509.NameAttribute(NameOID.SURNAME, csr_serial_number),   # csr.serial.number-- has to be this format 
                x509.NameAttribute(NameOID.USER_ID, csr_organization_identifier),   # csr.organization.identifier - has to be 13 digit with starting and ending digit 3  
                x509.NameAttribute(NameOID.TITLE, csr_invoice_type),  # csr.invoice.type - has to be 1100
                x509.NameAttribute(NameOID.BUSINESS_CATEGORY, csr_industry_business_category + "/registeredAddress=" + csr_location_address),   # csr.location.address
            ])),
        })

        csr = (
            x509.CertificateSigningRequestBuilder()
            .subject_name(dn)
            .add_extension(custom_extension, critical=False)
            .add_extension(alt_name, critical=False)
            .sign(private_key, hashes.SHA256(), backend=default_backend())
        )
        mycsr = csr.public_bytes(serialization.Encoding.PEM)
        base64csr = base64.b64encode(mycsr)
        encoded_string = base64csr.decode('utf-8')
        return private_key_pem,encoded_string

privateKey,csr_string = create_csr("sandbox")
# get_csr_data()
# print(privatekey)
with open('new_csr.csr', 'w') as file:
    file.write(csr_string)
with open('new_private.pem', 'w') as file:
    file.write(privateKey.decode('utf-8'))
# print(csr_string)

def create_csid():
    url = "https://gw-fatoora.zatca.gov.sa/e-invoicing/developer-portal/compliance"
    payload = json.dumps({
    "csr": csr_string
    })
    headers = {
    'accept': 'application/json',
    'OTP': '123345',
    'Accept-Version': 'V2',
    'Content-Type': 'application/json',
    'Cookie': 'TS0106293e=0132a679c07400f36242c054cc5c73a634f51486563baa5cc4d51293c0b38f68d10c82161b3074b1b2dfbe83a1ae5b78f2fd256699'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    data=json.loads(response.text)
                    # compliance_cert =get_auth_headers(data["binarySecurityToken"],data["secret"])
    concatenated_value = data["binarySecurityToken"] + ":" + data["secret"]
    encoded_value = base64.b64encode(concatenated_value.encode()).decode()

    with open(f"certficatejavaaa.pem", 'w') as file:   #attaching X509 certificate
        file.write(base64.b64decode(data["binarySecurityToken"]).decode('utf-8'))
# create_csid()

def fetch_content_from_url(url):
    """Fetches content from a specified URL."""
    response = requests.get(url)
    if response.status_code == 200:
        return response.content
    else:
        raise Exception(f"Failed to fetch content from {url}")

def apply_xsl_transformation(xml_input_bytes, xsl_content_bytes):
    """Applies an XSL transformation to an XML input."""
    xml_tree = etree.fromstring(xml_input_bytes)
    xsl_tree = etree.fromstring(xsl_content_bytes)
    transform = etree.XSLT(xsl_tree)
    result_tree = transform(xml_tree)
    return etree.tostring(result_tree, pretty_print=True)

def transform_xml():
    xml_file_path = "finalzatcaxml.xml"
    base_url = "https://raw.githubusercontent.com/y2n0s/ZatcaDemo/8211c298125b06fa766a12836418d9428d2ba63a/EInvoiceKSADemo.Helpers/Zatca/Files/Data/"
    steps = [
        ("removeElements.xsl", None),
        ("addUBLElement.xsl", None),
        (None, ("UBL-TO-BE-REPLACED", "ubl.xml")),
        ("addQRElement.xsl", None),
        (None, ("QR-TO-BE-REPLACED", "qr.xml")),
        ("addSignatureElement.xsl", None),
        (None, ("SIGN-TO-BE-REPLACED", "signature.xml")),
    ]

    with open(xml_file_path, 'rb') as xml_file:
        xml_content = xml_file.read()

    for step in steps:
        xsl_file, placeholder = step
        if xsl_file:
            xsl_url = base_url + xsl_file
            xsl_content = fetch_content_from_url(xsl_url)
            xml_content = apply_xsl_transformation(xml_content, xsl_content)
        elif placeholder:
            placeholder_text, replacement_file = placeholder
            replacement_url = base_url + replacement_file
            replacement_content = fetch_content_from_url(replacement_url)
            xml_content = xml_content.replace(placeholder_text.encode(), replacement_content)
            # print(xml_content)
            
    output_file_path = "transformed.xml"
    with open(output_file_path, 'wb') as output_file:
        output_file.write(xml_content)
# transform_xml()
def create_public_key(private_key_pem):
    private_key = serialization.load_pem_private_key(
        private_key_pem,
        password=None,
        backend=default_backend()
    )
    public_key = private_key.public_key()
    public_key_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo
    )
    return public_key_pem

import struct
import base64
import hashlib
import datetime

class TLVMessage:
    def __init__(self, tag, tag_name, value):
        self.tag = tag
        self.tag_name = tag_name
        self.value = value

    def to_bytes(self):
        tag_bytes = struct.pack('>B', self.tag)
        length_bytes = struct.pack('>B', len(self.value))
        if isinstance(self.value, str):
            value_bytes = self.value.encode('utf-8')
        elif isinstance(self.value, bytes):
            value_bytes = self.value
        else:
            raise ValueError("Unsupported value type for TLVMessage")
        return tag_bytes + length_bytes + value_bytes
    
class QRCodeGeneratorService:
    def generate_qr_code(self, seller_name, vat_registration_number, time_stamp, invoice_total, vat_total, xml_file_path, public_key, digital_signature, is_simplified, certificate_signature):
        with open(xml_file_path, 'rb') as xml_file:
            xml_content = xml_file.read()
        hashed_xml = base64.b64encode(hashlib.sha256(xml_content).digest()).decode('utf-8')

        tlv_messages = [
            TLVMessage(1, "Seller Name", seller_name),
            TLVMessage(2, "VAT Registration Number", vat_registration_number),
            TLVMessage(3, "Timestamp", time_stamp),
            TLVMessage(4, "Invoice Total", invoice_total),
            TLVMessage(5, "VAT Total", vat_total),
            TLVMessage(6, "Hashed XML", hashed_xml),
            TLVMessage(7, "Digital Signature", digital_signature),
            TLVMessage(8, "Public Key", base64.b64encode(public_key).decode('utf-8'))
        ]

        if is_simplified:
            tlv_messages.append(TLVMessage(9, "Certificate Signature", base64.b64encode(certificate_signature).decode('utf-8')))

        qr_code_bytes = b''.join([msg.to_bytes() for msg in tlv_messages])
        return base64.b64encode(qr_code_bytes).decode('utf-8')

def generate_qr_code_for_invoice(seller_name, vat_registration_number, invoice_total, vat_total, xml_file_path, public_key, digital_signature, is_simplified, certificate_signature):
    generator = QRCodeGeneratorService()
    qr_code_value = generator.generate_qr_code(
        seller_name=seller_name,
        vat_registration_number=vat_registration_number,
        time_stamp=datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
        invoice_total=invoice_total,
        vat_total=vat_total,
        xml_file_path=xml_file_path,
        public_key=public_key,
        digital_signature=digital_signature,
        is_simplified=is_simplified,
        certificate_signature=certificate_signature
    )
    return qr_code_value

qr_code_value = generate_qr_code_for_invoice(
    seller_name="Firoz Ashraf",
    vat_registration_number="1234567891",
    invoice_total="100.00",
    vat_total="15.00",
    xml_file_path="transformed.xml",
    public_key=create_public_key(private_key_pem),
    digital_signature=b"digital_signature_bytes",
    is_simplified=True,
    certificate_signature=b"certificate_signature_bytes"
)
print("QR Code Value:", qr_code_value)


def get_xml_hash():
    with open("transformed.xml", 'rb') as xml_file:
        xml_content = xml_file.read()
    hash_digest = hashlib.sha256(xml_content).digest()
    base64_hash = base64.b64encode(hash_digest).decode('utf-8')
    return base64_hash  


from cryptography import x509
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
from lxml import etree
import base64

# Load the private key
with open("new_private.pem", 'rb') as key_file:
    private_key = serialization.load_pem_private_key(
        key_file.read(),
        password=None,
    )
with open("certficatejavaaa.pem", 'r') as file:
    certificate_content = file.read()
    print(certificate_content)
cert_path = 'certificatejavaa2.pem'
with open(cert_path, "w") as file:
    file.write("-----BEGIN CERTIFICATE-----\n")
    file.write("\n".join(certificate_content[i:i+64] for i in range(0, len(certificate_content), 64)))
    file.write("\n-----END CERTIFICATE-----\n")

print("Certificate saved to certificatejavaa2.pem")
# Load the certificate
with open("certificatejavaa2.pem", 'rb') as cert_file:
    cert_data = cert_file.read()
    certificate = x509.load_pem_x509_certificate(cert_data)

# Encode the certificate in base64
encoded_certificate = base64.b64encode(cert_data).decode('utf-8')

# Get issuer name and serial number from the certificate
issuer_name = certificate.issuer.rfc4514_string()
serial_number = certificate.serial_number

# Load the XML content
with open("transformed.xml", 'rb') as xml_file:
    xml_content = xml_file.read()

# Parse the XML
parser = etree.XMLParser(remove_blank_text=True)
tree = etree.fromstring(xml_content, parser)

# Canonicalize the XML for signing
canonical_xml = etree.tostring(tree, method="c14n")

# Compute the digest
digest = hashes.Hash(hashes.SHA256())
digest.update(canonical_xml)
hash_value = digest.finalize()

# Sign the digest
signature = private_key.sign(
    hash_value,
    ec.ECDSA(hashes.SHA256())
)

encoded_signature = base64.b64encode(signature).decode('utf-8')

# Set the signature, certificate, issuer name, and serial number in the XML
signature_element = etree.SubElement(tree, "{http://www.w3.org/2000/09/xmldsig#}Signature")
signature_value_element = etree.SubElement(signature_element, "{http://www.w3.org/2000/09/xmldsig#}SignatureValue")
signature_value_element.text = encoded_signature

key_info_element = etree.SubElement(signature_element, "{http://www.w3.org/2000/09/xmldsig#}KeyInfo")
x509_data_element = etree.SubElement(key_info_element, "{http://www.w3.org/2000/09/xmldsig#}X509Data")
x509_certificate_element = etree.SubElement(x509_data_element, "{http://www.w3.org/2000/09/xmldsig#}X509Certificate")
x509_certificate_element.text = encoded_certificate

x509_issuer_serial_element = etree.SubElement(x509_data_element, "{http://www.w3.org/2000/09/xmldsig#}X509IssuerSerial")
x509_issuer_name_element = etree.SubElement(x509_issuer_serial_element, "{http://www.w3.org/2000/09/xmldsig#}X509IssuerName")
x509_issuer_name_element.text = issuer_name
x509_serial_number_element = etree.SubElement(x509_issuer_serial_element, "{http://www.w3.org/2000/09/xmldsig#}X509SerialNumber")
x509_serial_number_element.text = str(serial_number)

# Set the QR code value in the XML
qr_code = qr_code_value
qr_code_element = tree.find('.//cac:Attachment/cbc:EmbeddedDocumentBinaryObject', namespaces={'cac': 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2', 'cbc': 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2'})
if qr_code_element is not None:
    qr_code_element.text = qr_code

# Save the modified XML
with open("signed_transformed.xml", "wb") as f:
    f.write(etree.tostring(tree, pretty_print=True))
